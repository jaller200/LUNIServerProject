<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: Replica Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Replica Class Reference<br>
<small>
[<a class="el" href="group__REPLICA__MANAGER__GROUP.html">ReplicaManager</a>]</small>
</h1><!-- doxytag: class="Replica" --><!-- doxytag: inherits="NetworkIDObject" -->The interface to derive your game's networked classes from.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Replica.h&gt;</code>
<p>
<p>Inheritance diagram for Replica:
<p><center><img src="classReplica.png" usemap="#Replica_map" border="0" alt=""></center>
<map name="Replica_map">
<area href="classNetworkIDObject.html" alt="NetworkIDObject" shape="rect" coords="0,0,107,24">
</map>
<a href="classReplica-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#6906e759b6f8591303eee7b77e8e175b">SendConstruction</a> (RakNetTime currentTime, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, unsigned int &amp;flags, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, bool *includeTimestamp)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#740fc653aa0415b3d62677723477ed45">SendDestruction</a> (<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool *includeTimestamp)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#0e29c6f3e7118f094cbcd424e2f374d0">ReceiveDestruction</a> (<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, RakNetTime timestamp)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#23a61fd40c4c111376c758cb5c062932">SendScopeChange</a> (bool inScope, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, RakNetTime currentTime, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool *includeTimestamp)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#9077bbe9b0a2e4804be48e2f5119ccb0">ReceiveScopeChange</a> (<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, RakNetTime timestamp)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#6e17a6c20caa6fbd08a7c200ccc9013a">Serialize</a> (bool *sendTimestamp, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *outBitStream, RakNetTime lastSendTime, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> *priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> *reliability, RakNetTime currentTime, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, unsigned int &amp;flags)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#bddc526ca58d78c14e20dd2ce44c7a36">Deserialize</a> (<a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *inBitStream, RakNetTime timestamp, RakNetTime lastDeserializeTime, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReplica.html#4eda87273c97654da0cfd7dde5fac967">GetSortPriority</a> (void) const =0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The interface to derive your game's networked classes from. 
<p>
This is an interface of a replicated object for use in the framework of <a class="el" href="classReplicaManager.html">ReplicaManager</a> You should derive from this class, implementing the functions to provide the behavior you want. If your architecture doesn't allow you to derive from this class, you can store an instance of a derived instance of this class in your base game object. In that case, use <a class="el" href="classNetworkIDObject.html#4362e3bc3ec806ecb62736a02d342a6d">GetParent()</a> and <a class="el" href="classNetworkIDObject.html#48e4297abc90c622b9647053356feb82">SetParent()</a> and propagate the function calls up to your real classes. For an example where I do this, see Monster.h in the ReplicaManagerCS sample. <dl class="note" compact><dt><b>Note:</b></dt><dd>All send functions are called one for every target recipient, so you can customize the data sent per-user. </dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6906e759b6f8591303eee7b77e8e175b"></a><!-- doxytag: member="Replica::SendConstruction" ref="6906e759b6f8591303eee7b77e8e175b" args="(RakNetTime currentTime, SystemAddress systemAddress, unsigned int &amp;flags, RakNet::BitStream *outBitStream, bool *includeTimestamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::SendConstruction           </td>
          <td>(</td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>outBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>includeTimestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called in the first update tick after this object is first passed to ReplicaManager::Replicate for each player, and also when a new participant joins The intent of this function is to tell another system to create an instance of this class. You can do this however you want - I recommend having each class having a string identifier which is registered with StringTable, and then using EncodeString to write the name of the class. In the callback passed to SetReceiveConstructionCB create an instance of the object based on that string. <dl class="note" compact><dt><b>Note:</b></dt><dd>If you return true from IsNetworkIDAuthority, which you should do for a server or peer, I recommend encoding the value returned by <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">GetNetworkID()</a> into your bitstream and calling SetNetworkID with that value in your SetReceiveConstructionCB callback. <p>
Dereplicate, SetScope, and SignalSerializeNeeded all rely on being able to call GET_OBJECT_FROM_ID which requires that SetNetworkID be called on that object. <p>
SendConstruction is called once for every new player that connects and every existing player when an object is passed to Replicate. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentTime</em>&nbsp;</td><td>The current time that would be returned by <a class="el" href="namespaceRakNet.html#aa2d77435e0bf2c56c77f6f41739d4b4">RakNet::GetTime()</a>. That's a slow call I do already, so you can use the parameter instead of having to call it yourself. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send to. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Per-object per-system serialization flags modified by this function, <a class="el" href="classReplicaManager.html#b24556810cd7362fd3f70833ff811c78">ReplicaManager::SignalSerializationFlags</a>, and <a class="el" href="classReplicaManager.html#9c6b5b7a5e6332fb17e74ab103739d04">ReplicaManager::AccessSerializationFlags</a>. Useful for simple customization of what you serialize based on application events. This value is not automatically reset. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outBitStream</em>&nbsp;</td><td>The data you want to write in the message. If you do not write to outBitStream and return true, then no send call will occur and the system will consider this object as not created on that remote system. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>includeTimestamp</em>&nbsp;</td><td>Set to true to include a timestamp with the message. This will be reflected in the timestamp parameter of the callback. Defaults to false. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>

</div>
</div><p>
<a class="anchor" name="740fc653aa0415b3d62677723477ed45"></a><!-- doxytag: member="Replica::SendDestruction" ref="740fc653aa0415b3d62677723477ed45" args="(RakNet::BitStream *outBitStream, SystemAddress systemAddress, bool *includeTimestamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::SendDestruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>outBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>includeTimestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The purpose of the function is to send a packet containing the data in <em>outBitStream</em> to <em>systemAddress</em> telling that system that Dereplicate was called. In the code, this is called in the update cycle after you call <a class="el" href="classReplicaManager.html#d9c9f2cd9e9496576a78c92049d80214">ReplicaManager::Destruct()</a>. Then, if you write to outBitStream, a message is sent to that participant. This is the one send you cannot delay because objects may be deleted and we can't read into them past this. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outBitStream</em>&nbsp;</td><td>The data to send. If you do not write to outBitStream, then no send call will occur </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send to. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>includeTimestamp</em>&nbsp;</td><td>Set to true to include a timestamp with the message. This will be reflected in the timestamp parameter of the callback. Defaults to false. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e29c6f3e7118f094cbcd424e2f374d0"></a><!-- doxytag: member="Replica::ReceiveDestruction" ref="0e29c6f3e7118f094cbcd424e2f374d0" args="(RakNet::BitStream *inBitStream, SystemAddress systemAddress, RakNetTime timestamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::ReceiveDestruction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>inBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is called when SendDestruction is sent from another system. Delete your object if you want. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inBitStream</em>&nbsp;</td><td>What was sent in SendDestruction::outBitStream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant that sent this message to us. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timestamp</em>&nbsp;</td><td>if Serialize::SendDestruction was set to true, the time the packet was sent. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult. Only REPLICA_PROCESSING_DONE is valid, and will send the destruction message. Anything else will not send any messages. </dd></dl>

</div>
</div><p>
<a class="anchor" name="23a61fd40c4c111376c758cb5c062932"></a><!-- doxytag: member="Replica::SendScopeChange" ref="23a61fd40c4c111376c758cb5c062932" args="(bool inScope, RakNet::BitStream *outBitStream, RakNetTime currentTime, SystemAddress systemAddress, bool *includeTimestamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::SendScopeChange           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inScope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>outBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>includeTimestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="classReplicaManager.html#d63c303bd6fb995dd8e52c0e84998f3c">ReplicaManager::SetScope</a> is called with a different value than what it currently has. It is up to you to write <em>inScope</em> to <em>outBitStream</em>. Not doing so, and returning true, means you want to cancel the scope change call. If <em>inScope</em> is true, you return true, and data is written to outBitStream, then Serialize will be called automatically This is a convenience feature, since there's almost no case where an object would go in scope but not be serialized <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inScope</em>&nbsp;</td><td>The new scope that will be sent to ReceiveScopeChange that originally came from SetScope </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outBitStream</em>&nbsp;</td><td>The data to send. If you do not write to outBitStream and return true, then no send will occur and the object will keep its existing scope </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentTime</em>&nbsp;</td><td>The current time that would be returned by <a class="el" href="namespaceRakNet.html#aa2d77435e0bf2c56c77f6f41739d4b4">RakNet::GetTime()</a>. That's a slow call I do already, so you can use the parameter instead of having to call it yourself. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant to send to. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>includeTimestamp</em>&nbsp;</td><td>Set to true to include a timestamp with the message. This will be reflected in the timestamp parameter of the callback. Defaults to false. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>

</div>
</div><p>
<a class="anchor" name="9077bbe9b0a2e4804be48e2f5119ccb0"></a><!-- doxytag: member="Replica::ReceiveScopeChange" ref="9077bbe9b0a2e4804be48e2f5119ccb0" args="(RakNet::BitStream *inBitStream, SystemAddress systemAddress, RakNetTime timestamp)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::ReceiveScopeChange           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>inBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when when we get the SendScopeChange message. The new scope should have been encoded (by you) into <em>inBitStream</em> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inBitStream</em>&nbsp;</td><td>What was sent in SendScopeChange::outBitStream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant that sent this message to us. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timestamp</em>&nbsp;</td><td>if Serialize::SendScopeChange was set to true, the time the packet was sent. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e17a6c20caa6fbd08a7c200ccc9013a"></a><!-- doxytag: member="Replica::Serialize" ref="6e17a6c20caa6fbd08a7c200ccc9013a" args="(bool *sendTimestamp, RakNet::BitStream *outBitStream, RakNetTime lastSendTime, PacketPriority *priority, PacketReliability *reliability, RakNetTime currentTime, SystemAddress systemAddress, unsigned int &amp;flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::Serialize           </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>sendTimestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>outBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>lastSendTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> *&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> *&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="classReplicaManager.html#1dba75dce05f3f559c97ffd1b21930d4">ReplicaManager::SignalSerializeNeeded</a> is called with this object as the parameter. The system will ensure that Serialize only occurs for participants that have this object constructed and in scope The intent of this function is to serialize all your class member variables for remote transmission. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sendTimestamp</em>&nbsp;</td><td>Set to true to include a timestamp with the message. This will be reflected in the timestamp parameter Deserialize. Defaults to false. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outBitStream</em>&nbsp;</td><td>The data you want to write in the message. If you do not write to outBitStream and return true, then no send will occur for this participant. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastSendTime</em>&nbsp;</td><td>The last time Serialize returned true and outBitStream was written to. 0 if this is the first time the function has ever been called for this <em>systemAddress</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Passed to <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send</a> for the send call. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>Passed to <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send</a> for the send call. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentTime</em>&nbsp;</td><td>The current time that would be returned by <a class="el" href="namespaceRakNet.html#aa2d77435e0bf2c56c77f6f41739d4b4">RakNet::GetTime()</a>. That's a slow call I do already, so you can use the parameter instead of having to call it yourself. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant we are sending to. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Per-object per-system serialization flags modified by this function, <a class="el" href="classReplicaManager.html#b24556810cd7362fd3f70833ff811c78">ReplicaManager::SignalSerializationFlags</a>, and <a class="el" href="classReplicaManager.html#9c6b5b7a5e6332fb17e74ab103739d04">ReplicaManager::AccessSerializationFlags</a>. Useful for simple customization of what you serialize based on application events. This value is not automatically reset. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>See ReplicaReturnResult </dd></dl>

</div>
</div><p>
<a class="anchor" name="bddc526ca58d78c14e20dd2ce44c7a36"></a><!-- doxytag: member="Replica::Deserialize" ref="bddc526ca58d78c14e20dd2ce44c7a36" args="(RakNet::BitStream *inBitStream, RakNetTime timestamp, RakNetTime lastDeserializeTime, SystemAddress systemAddress)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ReplicaEnums_8h.html#5184a4d04fa17bbf4e2c98143215cba5">ReplicaReturnResult</a> Replica::Deserialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>inBitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>lastDeserializeTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when another participant called Serialize with our system as the target <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inBitStream</em>&nbsp;</td><td>What was written to Serialize::outBitStream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timestamp</em>&nbsp;</td><td>if Serialize::SendTimestamp was set to true, the time the packet was sent. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastDeserializeTime</em>&nbsp;</td><td>Last time you returned true from this function for this object, or 0 if never, regardless of <em>systemAddress</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The participant that sent this message to us. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4eda87273c97654da0cfd7dde5fac967"></a><!-- doxytag: member="Replica::GetSortPriority" ref="4eda87273c97654da0cfd7dde5fac967" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Replica::GetSortPriority           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used to sort the order that commands (construct, serialize) take place in. Lower sort priority commands happen before higher sort priority commands. Same sort priority commands take place in random order. For example, if both players and player lists are replicas, you would want to create the players before the player lists if the player lists refer to the players. So you could specify the players as priority 0, and the lists as priority 1, and the players would be created and serialized first <dl class="return" compact><dt><b>Returns:</b></dt><dd>A higher value to process later, a lower value to process sooner, the same value to process in random order. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>C:/RakNet/Source/<a class="el" href="Replica_8h.html">Replica.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jul 27 15:10:19 2008 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
