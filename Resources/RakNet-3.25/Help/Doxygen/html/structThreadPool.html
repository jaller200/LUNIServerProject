<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</h1><!-- doxytag: class="ThreadPool" --><code>#include &lt;ThreadPool.h&gt;</code>
<p>
<a href="structThreadPool-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#248bc5745f49ff001441a23a1841f18e">StartThreads</a> (int numThreads, int stackSize, void *(*_perThreadDataFactory)()=0, void(*_perThreadDataDestructor)(void *)=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d93b8ba41d96c5f0f814ae0acabfcdfc"></a><!-- doxytag: member="ThreadPool::StopThreads" ref="d93b8ba41d96c5f0f814ae0acabfcdfc" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#d93b8ba41d96c5f0f814ae0acabfcdfc">StopThreads</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops all threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#5f64a8c4a4400106a2d7d03f7f9de132">AddInput</a> (OutputType(*workerThreadCallback)(InputType, bool *returnOutput, void *perThreadData), InputType inputData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#925d6c332e4c48bc99dc5750dfd5fcdd">HasOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#5d517170f4b61211325ac5c9717e32e1">HasOutputFast</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#ac1ae43b7b3581b5ae9803c7cae7b724">HasInput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#dde82517b452d9a74e91114a3783ce02">HasInputFast</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#568e3e2035977a38ad35aeee74ed7388">GetOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1e0cc5c3c8786fc49f60aef34160cbd"></a><!-- doxytag: member="ThreadPool::Clear" ref="f1e0cc5c3c8786fc49f60aef34160cbd" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#f1e0cc5c3c8786fc49f60aef34160cbd">Clear</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears internal buffers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#024e2da38f846fc76d1fb16cf13c1b90">LockInput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="710a554919e550501f9f06ab61e1d911"></a><!-- doxytag: member="ThreadPool::UnlockInput" ref="710a554919e550501f9f06ab61e1d911" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#710a554919e550501f9f06ab61e1d911">UnlockInput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the input buffer after you are done with the functions InputSize, GetInputAtIndex, and RemoveInputAtIndex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c7631f35a83c4f992b881174b6c8eff"></a><!-- doxytag: member="ThreadPool::InputSize" ref="0c7631f35a83c4f992b881174b6c8eff" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#0c7631f35a83c4f992b881174b6c8eff">InputSize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of the input queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09194411e4f4d87804111459fad24522"></a><!-- doxytag: member="ThreadPool::GetInputAtIndex" ref="09194411e4f4d87804111459fad24522" args="(unsigned index)" -->
InputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#09194411e4f4d87804111459fad24522">GetInputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the input at a specified index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e41bfe6660b1a55cbf14b99b77defac"></a><!-- doxytag: member="ThreadPool::RemoveInputAtIndex" ref="7e41bfe6660b1a55cbf14b99b77defac" args="(unsigned index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#7e41bfe6660b1a55cbf14b99b77defac">RemoveInputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove input from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#384ba5c62d60ac2e12e3f8aeea30d8bc">LockOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6e5208df0686a4a76ecb3bbcc6ffcb2"></a><!-- doxytag: member="ThreadPool::UnlockOutput" ref="f6e5208df0686a4a76ecb3bbcc6ffcb2" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#f6e5208df0686a4a76ecb3bbcc6ffcb2">UnlockOutput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the output buffer after you are done with the functions OutputSize, GetOutputAtIndex, and RemoveOutputAtIndex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2ebae170e7dbdbad6034ba69271f86f"></a><!-- doxytag: member="ThreadPool::OutputSize" ref="c2ebae170e7dbdbad6034ba69271f86f" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#c2ebae170e7dbdbad6034ba69271f86f">OutputSize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of the output queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de45848613e8230e5324edabe40fcde9"></a><!-- doxytag: member="ThreadPool::GetOutputAtIndex" ref="de45848613e8230e5324edabe40fcde9" args="(unsigned index)" -->
OutputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#de45848613e8230e5324edabe40fcde9">GetOutputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the output at a specified index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb4958a8df475d6060bede0fa4af7faa"></a><!-- doxytag: member="ThreadPool::RemoveOutputAtIndex" ref="fb4958a8df475d6060bede0fa4af7faa" args="(unsigned index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#fb4958a8df475d6060bede0fa4af7faa">RemoveOutputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove output from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="568d636d8a27645c6641d3b4cc7308f6"></a><!-- doxytag: member="ThreadPool::ClearInput" ref="568d636d8a27645c6641d3b4cc7308f6" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#568d636d8a27645c6641d3b4cc7308f6">ClearInput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all items from the input queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d8d2d173ca5ddb99614ed5b9df1fb85"></a><!-- doxytag: member="ThreadPool::ClearOutput" ref="8d8d2d173ca5ddb99614ed5b9df1fb85" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#8d8d2d173ca5ddb99614ed5b9df1fb85">ClearOutput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all items from the output queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90b37c13ba8b9f67db4bd99ee4a5d811"></a><!-- doxytag: member="ThreadPool::IsWorking" ref="90b37c13ba8b9f67db4bd99ee4a5d811" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#90b37c13ba8b9f67db4bd99ee4a5d811">IsWorking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are any of the threads working, or is input or output available? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad431a8d3f28af0ae5249c7e3b819307"></a><!-- doxytag: member="ThreadPool::NumThreadsWorking" ref="ad431a8d3f28af0ae5249c7e3b819307" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#ad431a8d3f28af0ae5249c7e3b819307">NumThreadsWorking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of currently active threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4f4a4bad3d651296768d22d9954647b6"></a><!-- doxytag: member="ThreadPool::WasStopped" ref="4f4a4bad3d651296768d22d9954647b6" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#4f4a4bad3d651296768d22d9954647b6">WasStopped</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Have the threads been signaled to be stopped? <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class InputType, class OutputType&gt;<br>
 struct ThreadPool&lt; InputType, OutputType &gt;</h3>

A simple class to create worker threads that processes a queue of functions with data. This class does not allocate or deallocate memory. It is up to the user to handle memory management. InputType and OutputType are stored directly in a queue. For large structures, if you plan to delete from the middle of the queue, you might wish to store pointers rather than the structures themselves so the array can shift efficiently. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="248bc5745f49ff001441a23a1841f18e"></a><!-- doxytag: member="ThreadPool::StartThreads" ref="248bc5745f49ff001441a23a1841f18e" args="(int numThreads, int stackSize, void *(*_perThreadDataFactory)()=0, void(*_perThreadDataDestructor)(void *)=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::StartThreads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)()&nbsp;</td>
          <td class="paramname"> <em>_perThreadDataFactory</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>_perThreadDataDestructor</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the specified number of threads. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numThreads</em>&nbsp;</td><td>The number of threads to start </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stackSize</em>&nbsp;</td><td>0 for default (except on consoles). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_perThreadDataFactory</em>&nbsp;</td><td>User callback to return data stored per thread. Pass 0 if not needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_perThreadDataDestructor</em>&nbsp;</td><td>User callback to destroy data stored per thread, created by _perThreadDataFactory. Pass 0 if not needed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5f64a8c4a4400106a2d7d03f7f9de132"></a><!-- doxytag: member="ThreadPool::AddInput" ref="5f64a8c4a4400106a2d7d03f7f9de132" args="(OutputType(*workerThreadCallback)(InputType, bool *returnOutput, void *perThreadData), InputType inputData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::AddInput           </td>
          <td>(</td>
          <td class="paramtype">OutputType(*)(InputType, bool *returnOutput, void *perThreadData)&nbsp;</td>
          <td class="paramname"> <em>workerThreadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputType&nbsp;</td>
          <td class="paramname"> <em>inputData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function to a queue with data to pass to that function. This function will be called from the thread Memory management is your responsibility! This class does not allocate or deallocate memory. The best way to deallocate <em>inputData</em> is in userCallback. If you call EndThreads such that callbacks were not called, you can iterate through the inputQueue and deallocate all pending input data there The best way to deallocate output is as it is returned to you from GetOutput. Similarly, if you end the threads such that not all output was returned, you can iterate through outputQueue and deallocate it there. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>workerThreadCallback</em>&nbsp;</td><td>The function to call from the thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputData</em>&nbsp;</td><td>The parameter to pass to <em>userCallback</em> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="925d6c332e4c48bc99dc5750dfd5fcdd"></a><!-- doxytag: member="ThreadPool::HasOutput" ref="925d6c332e4c48bc99dc5750dfd5fcdd" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if output from GetOutput is waiting. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if output is waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d517170f4b61211325ac5c9717e32e1"></a><!-- doxytag: member="ThreadPool::HasOutputFast" ref="5d517170f4b61211325ac5c9717e32e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutputFast           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inaccurate but fast version of HasOutput. If this returns true, you should still check HasOutput for the real value. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if output is probably waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac1ae43b7b3581b5ae9803c7cae7b724"></a><!-- doxytag: member="ThreadPool::HasInput" ref="ac1ae43b7b3581b5ae9803c7cae7b724" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if input from GetInput is waiting. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if input is waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="dde82517b452d9a74e91114a3783ce02"></a><!-- doxytag: member="ThreadPool::HasInputFast" ref="dde82517b452d9a74e91114a3783ce02" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInputFast           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inaccurate but fast version of HasInput. If this returns true, you should still check HasInput for the real value. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if input is probably waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="568e3e2035977a38ad35aeee74ed7388"></a><!-- doxytag: member="ThreadPool::GetOutput" ref="568e3e2035977a38ad35aeee74ed7388" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputType <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::GetOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the output of a call to <em>userCallback</em> HasOutput must return true before you call this function. Otherwise it will assert. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The output of <em>userCallback</em>. If you have different output signatures, it is up to you to encode the data to indicate this </dd></dl>

</div>
</div><p>
<a class="anchor" name="024e2da38f846fc76d1fb16cf13c1b90"></a><!-- doxytag: member="ThreadPool::LockInput" ref="024e2da38f846fc76d1fb16cf13c1b90" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockInput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the input buffer before calling the functions InputSize, InputAtIndex, and RemoveInputAtIndex It is only necessary to lock the input or output while the threads are running 
</div>
</div><p>
<a class="anchor" name="384ba5c62d60ac2e12e3f8aeea30d8bc"></a><!-- doxytag: member="ThreadPool::LockOutput" ref="384ba5c62d60ac2e12e3f8aeea30d8bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType, class OutputType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the output buffer before calling the functions OutputSize, OutputAtIndex, and RemoveOutputAtIndex It is only necessary to lock the input or output while the threads are running 
</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>C:/RakNet/Source/ThreadPool.h</ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Jul 27 15:10:19 2008 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
